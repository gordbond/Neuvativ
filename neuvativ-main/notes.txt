I think we are using old versions of some libraries and may want to try updating these

- I had to run the following to get the npm install to work properly:

npm config set legacy-peer-deps true
npm i

I think I need to add this back in to AmplifyDependentResourcesAttributes

    "auth": {
        "userPoolGroups": {
            "AdminGroupRole": "string",
            "ElevatorCompanyGroupRole": "string",
            "BuildingManagerGroupRole": "string",
            "GuestGroupRole": "string"
        },
        "tsaroAuth": {
            "IdentityPoolId": "string",
            "IdentityPoolName": "string",
            "UserPoolId": "string",
            "UserPoolArn": "string",
            "UserPoolName": "string",
            "AppClientIDWeb": "string",
            "AppClientID": "string"
        }
    },


FULL FILE: 

export type AmplifyDependentResourcesAttributes = {
    "auth": {
        "userPoolGroups": {
            "AdminGroupRole": "string",
            "ElevatorCompanyGroupRole": "string",
            "BuildingManagerGroupRole": "string",
            "GuestGroupRole": "string"
        },
        "tsaroAuth": {
            "IdentityPoolId": "string",
            "IdentityPoolName": "string",
            "UserPoolId": "string",
            "UserPoolArn": "string",
            "UserPoolName": "string",
            "AppClientIDWeb": "string",
            "AppClientID": "string"
        }
    },
    "function": {
        "tsaroAuthPostAuthentication": {
            "Name": "string",
            "Arn": "string",
            "LambdaExecutionRole": "string",
            "Region": "string"
        },
        "urlDashboardUpdate": {
            "Name": "string",
            "Arn": "string",
            "Region": "string",
            "LambdaExecutionRole": "string"
        },
        "tsaroAuthPostConfirmation": {
            "Name": "string",
            "Arn": "string",
            "LambdaExecutionRole": "string",
            "Region": "string"
        },
        "tsaroAuthPreSignup": {
            "Name": "string",
            "Arn": "string",
            "LambdaExecutionRole": "string",
            "Region": "string"
        }
    },
    "api": {
        "neuvativ": {
            "GraphQLAPIIdOutput": "string",
            "GraphQLAPIEndpointOutput": "string"
        }
    }
}


add-to-groups working

const aws = require('aws-sdk');
var ddb = new aws.DynamoDB();

const cognitoidentityserviceprovider = new aws.CognitoIdentityServiceProvider({
  apiVersion: '2016-04-18',
});

exports.handler = async (event, context) => {
  console.log("event.request.userAttributes:",event.request.userAttributes);
  console.log("event.request.userAttributes.email_verified:",event.request.userAttributes.email_verified);

    // --Read the group that the user belongs to 
    var paramsReadGroup = {
      UserPoolId: process.env.userPoolId, /* required */
      Username: event.request.userAttributes.sub, /* required */
    };
    try {
      let readGroupRes = await cognitoidentityserviceprovider.adminListGroupsForUser(paramsReadGroup).promise();
      let specificGroup  = readGroupRes.Groups.map(x => x.GroupName);
      console.log("Success, the group that the user belongs to has been obtained",specificGroup[0]);
      
      if (specificGroup[0]!=="Admin" || specificGroup[0]!=="ElevatorCompany" || specificGroup[0]!=="BuildingManager" || specificGroup[0]!=="Guest"){
        let codeWasDeleted = false;
          // --- read group according to code in dynamo table
        var paramsScan = {
        TableName: process.env.TableName,
        ScanFilter: {
          'AssignedCodes': {
            ComparisonOperator: 'CONTAINS',
            AttributeValueList: [
              { S: event.request.userAttributes.zoneinfo},
            ]
          },
        },
        };
        try {
          let scanTable = await ddb.scan(paramsScan).promise();
          console.log("scanTable:",scanTable);
          let scanTable1 = scanTable.Items.map(x => x.SignUpGroup);
          console.log("scanTable1",scanTable1);
          let group = scanTable1[0].S;
          console.log("Group", group);
          console.log("Success, group has been obtained");
          const assignedCodesList = scanTable.Items.map(x => x.AssignedCodes)[0].L;
          console.log("Assigned Codes: ", assignedCodesList)
          // ----------Remove used code from the table
          let scanTable2 = scanTable.Items.map(x => x.id);
          console.log("SCAN TABLE 2: ", scanTable2)
          let elementId = scanTable2.map(x => x.S);
          console.log("elementId: ", elementId)
          console.log("event.request.userAttributes.zoneinfo: ", event.request.userAttributes.zoneinfo)
          const indexToRemove = assignedCodesList.findIndex(i => i.S === event.request.userAttributes.zoneinfo);
          const paramsUpdate = {
            // ExpressionAttributeValues: {':p' : {"L": [{
            //   "S": event.request.userAttributes.zoneinfo
            // }] } },
            Key: {
              "id": {
                S: elementId[0]
              }
            }, 
            ReturnValues: 'ALL_NEW', 
            TableName: process.env.TableName, 
            // UpdateExpression: `DELETE AssignedCodes :p`, 
            UpdateExpression: `REMOVE AssignedCodes[${indexToRemove}]`, 
          };
          
          try {
            let itemUpdated = await ddb.updateItem(paramsUpdate).promise();
            codeWasDeleted = true;
            console.log("Success, code used has been removed from table", itemUpdated);
          } catch (err) {
            console.log("Code used has not been removed from table ", err);
          }
          // ----- Add a new code to the table if used code was deleted
          if(codeWasDeleted){
            console.log("Adding new code to table...")
            //Random string function from https://stackoverflow.com/questions/10726909/random-alpha-numeric-string-in-javascript (user Nimphious)
            
            function randomString(length, chars) {
              //Prefix
              let prefix = '';
              if(group === 'Admin'){
                prefix = 'AD';
              }else if(group === 'ElevatorCompany'){
                prefix = 'EC';
              }else if(group === 'BuildingManager'){
                prefix = 'BM';
              }else{
                prefix = 'GU';
              }
              //Random string
              var mask = '';
              if (chars.indexOf('a') > -1) mask += 'abcdefghijklmnopqrstuvwxyz';
              if (chars.indexOf('A') > -1) mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
              if (chars.indexOf('#') > -1) mask += '0123456789';
              if (chars.indexOf('!') > -1) mask += '~`!@#$%^<>?,./|\\';
              var result = '';

              for (var i = length; i > 0; --i) result += mask[Math.round(Math.random() * (mask.length - 1))];

              //concat prefix to string
              result = prefix.concat(result);

              return result;
            }

            //Create a random to insert in dynamo db
            let codeToBeInserted = randomString(16, '#aA!')

            //Parameters 
            var paramsForNewCode = {
              ExpressionAttributeValues: {
              ":p": {
                "L": [
                    { "S": codeToBeInserted }
                ]
              }},
              ExpressionAttributeNames: {"#ac": "CurrentlyAvailableCodes"},
              Key: {
                "id": {
                  S: elementId[0]
                }
              }, 
              ReturnValues: 'ALL_NEW', 
              TableName: process.env.TableName, 
              UpdateExpression: `SET #ac = list_append(#ac, :p)`,
            };
            
            //Add new code to db
            try {
              const codesUpdated = await ddb.updateItem(paramsForNewCode).promise();
              console.log("Success, new code has been added to the table",codesUpdated);
            } catch (err) {
              console.log("Code has not been added to the table ", err);
            }
          }



          //----- assign user to a group
          const groupParams = {
            GroupName: group, 
            UserPoolId: event.userPoolId,
          };
          const addUserParams = {
            GroupName: group,
            UserPoolId: event.userPoolId,
            Username: event.userName,
          };
          /**
           * Check if the group exists; if it doesn't, create it.
           */
          try {
            await cognitoidentityserviceprovider.getGroup(groupParams).promise();
            console.log("Success, user has been assigned to a group",group);
          } catch (e) {
            await cognitoidentityserviceprovider.createGroup(groupParams).promise();
          }
          /**
           * Then, add the user to the group.
           */
          await cognitoidentityserviceprovider.adminAddUserToGroup(addUserParams).promise();
          // }   
        } catch (err) {
          console.log("Group has not been obtained", err);
          throw new Error(`The code ${event.request.userAttributes.zoneinfo} is not associated with any group`);
        }
      }
    } catch (err) {
      console.log("Print error", err);
      
    }

  return event;
};

import React, { useState, useEffect } from "react";
import Amplify, {Auth, API, graphqlOperation, Storage } from 'aws-amplify';
import * as mutations from '../graphql/mutations';
import * as queries from '../graphql/queries';
import { useNavigate } from "react-router-dom";
import { v4 as uuid } from 'uuid';
import awsconfig from '../aws-exports';
import awsExports from "../aws-exports";
import utils from "../utils";
Amplify.configure(awsconfig);
Auth.configure(awsExports);

function AdminForm() {

    let [userConnected, setUserConnected] = useState([]);
    let [userGroup, setUserGroup] = useState([]);
    let [groupType, setGroupType] = useState('');
    let [uniqueCode, setUniqueCode] = useState(""); 
    let [groupId, setGroupId] = useState();
    let [email, setEmail] = useState('');
    const [feedback, setFeedback] = useState('');
    const [success, setSuccess] = useState(false);

    //Create a random string to be used for the registration code
    const randomString = (length, chars) => {
        console.log("groupType: ", groupType)
        //Prefix
        let prefix = '';
        if(groupType === 'Admin'){
          prefix = 'AD';
        }else if(groupType === 'ElevatorCompany'){
          prefix = 'EC';
        }else if(groupType === 'BuildingManager'){
          prefix = 'BM';
        }else{
          prefix = 'GU';
        }
        //Random string
        var mask = '';
        if (chars.indexOf('a') > -1) mask += 'abcdefghijklmnopqrstuvwxyz';
        if (chars.indexOf('A') > -1) mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        if (chars.indexOf('#') > -1) mask += '0123456789';
        if (chars.indexOf('!') > -1) mask += '~`!@#$%^&*()_+-={}[]:";\'<>?,./|\\';
        var result = '';

        for (var i = length; i > 0; --i) result += mask[Math.round(Math.random() * (mask.length - 1))];

        //concat prefix to string
        result = prefix.concat(result);
        console.log("Created code: ", result);
        return result;
    }

    //Set unique code to send
    const fetchCodes = async () => {

        try{  
            //Make API call to get list of unique codes
            await API.graphql(graphqlOperation(queries.getSigUpCodeTable,{id: groupId})).then(res=>{
                //List of codes
                let codes = res.data.getSigUpCodeTable.CurrentlyAvailableCodes
                console.log("CODES BEFORE SPLIT: ", codes);
                //As long as there is a code
                if(codes.length > 0) {
                    setUniqueCode(codes[0]);
                }else{
                    setUniqueCode("No code available");
                }
            })
        }
        catch(err){
            console.log('err',err )
        }
    }

    //Updates the available codes and assigned codes table
    const updateCodes = async () => {
        //Remove code from Available
        try{  
            //Get list of codes
            await API.graphql(graphqlOperation(queries.getSigUpCodeTable,{id: groupId})).then(res=>{
                //List of codes
                let codes = res.data.getSigUpCodeTable.CurrentlyAvailableCodes
                //Assigned codes
                let assignedCodes = res.data.getSigUpCodeTable.AssignedCodes
                //As long as there is a code
                if(codes.length > 0) {
                    
                    //Remove first element from list
                    const removedCode = codes.shift();
                    //Add removed code from available codes to assigned codes 
                    assignedCodes.push(removedCode);
                    setUniqueCode(removedCode);

                    //Get a new code for available codes
                    const codeToBeInserted = randomString(16, '#aA!')
                    //Add to available codes
                    codes.push(codeToBeInserted)

                    //Updated available and assigned codes 
                    API.graphql(graphqlOperation(mutations.updateSigUpCodeTable, {input: {
                        id: groupId,
                        CurrentlyAvailableCodes: codes,
                        AssignedCodes: assignedCodes

                    }})).then(res=>{
                        //List of codes
                        let newList = res.data
                        console.log("New List: ", newList)
                        setSuccess(true)
                        setFeedback("Success: Registration code will open in your email.")
                    })
                }else{
                    setUniqueCode("No code available");
                }
                
            })
            
        }
        catch(err){
            console.log('err',err )
            setSuccess(false)
            setFeedback("Error: Registration code could not be created.")
        }
        //Update Assigned Codes 
    }

    //Handle changing Group ID
    const handleChangeSelect = ({ target: { value } }) => {
        
        setGroupId(value)
        const groupNum = parseInt(value)
        //Set name for user Group
        let group = ""
        switch (groupNum) {
            case 1: 
                group = "Admin"
            break;
            case 2:
                group = "ElevatorCompany"
            break;
            case 3:
                group = "BuildingManager"
            break;
            case 4:
                group = "Guest"
            break;
            default: 
                group = ""
        }
        setGroupType(group)
    }



    //Handle change of email field
    const handleFormChange = (event, index) => {       
        setEmail(event.target.value);
    }


    const handleSubmit = async (e) => {
        e.preventDefault()
        const subject = `Sign up code`
        const body = encodeURIComponent(`Your registration code is: \n\n ${uniqueCode} \n\n Thanks, \n Tsaro`)
        updateCodes()
        window.open(`mailto:${email}?subject=${subject}&body=${body}`);

    }

    


    //Get codes when page loads
    useEffect(() => {
        fetchCodes()
    }, [groupId])

    //Testing purposes
    useEffect(() => {
        console.log("GROUP CHANGED: ", groupType)
    }, [groupType])

    return (
        <div className={`form-container-sm`}>
            <legend className="caption">Send new registration code</legend>
            <form className="create-project-form " onSubmit={handleSubmit}>
                <div className="column">
                    <label className="form-label">Account Type :</label>
                    <select className="form-control" value={groupId} onChange={handleChangeSelect}>
                        <option disabled selected value>Select user type...</option>
                        <option value={1}>Admin</option>
                        <option value={2}>Elevator Company</option>
                        <option value={3}>Building Manager</option>
                        <option value={4}>Guest</option>
                    </select>
                </div>  
                <div className="column">
                    <label className="form-label">Email Address:</label>
                    <input
                        type="email"
                        name="deviceClass"
                        onChange={event => handleFormChange(event)}
                        value={email}
                        placeholder="someone@example.com"
                        autoComplete="off"
                        className="form-control"
                    />
                </div>
                {/* <div className="column">
                    <label className="form-label">Registration Code (read-only):</label>
                    <input
                        type="text"
                        name="deviceClass"
                        value={uniqueCode}
                        placeholder="ex Ad12345"
                        autoComplete="off"
                        className="form-control"
                        disabled
                    />
                </div> */}
                <br />
                <button
                    type="submit"
                    className="form-btn"
                    name="Send"
                >
                    Send Code
                </button>
                <br />
                <legend className={success ? 'feedback-success' : 'feedback-fail'}>{feedback}</legend>
            </form>
        </div>
    );

}

export default AdminForm;

ADD TO Groups

const aws = require('aws-sdk');
var ddb = new aws.DynamoDB();

const cognitoidentityserviceprovider = new aws.CognitoIdentityServiceProvider({
  apiVersion: '2016-04-18',
});

exports.handler = async (event, context) => {
  console.log("event.request.userAttributes:",event.request.userAttributes);
  console.log("event.request.userAttributes.email_verified:",event.request.userAttributes.email_verified);

    // --Read the group that the user belongs to 
    var paramsReadGroup = {
      UserPoolId: process.env.userPoolId, /* required */
      Username: event.request.userAttributes.sub, /* required */
    };
    try {
      let readGroupRes = await cognitoidentityserviceprovider.adminListGroupsForUser(paramsReadGroup).promise();
      let specificGroup  = readGroupRes.Groups.map(x => x.GroupName);
      console.log("Success, the group that the user belongs to has been obtained",specificGroup[0]);
      
      if (specificGroup[0]!=="Admin" || specificGroup[0]!=="ElevatorCompany" || specificGroup[0]!=="BuildingManager" || specificGroup[0]!=="Guest"){
        let codeWasDeleted = false;
          // --- read group according to code in dynamo table
        var paramsScan = {
        TableName: process.env.TableName,
        ScanFilter: {
          'AssignedCodes': {
            ComparisonOperator: 'CONTAINS',
            AttributeValueList: [
              { S: event.request.userAttributes.zoneinfo},
            ]
          },
        },
        };
        try {
          let scanTable = await ddb.scan(paramsScan).promise();
          console.log("scanTable:",scanTable);
          let scanTable1 = scanTable.Items.map(x => x.SignUpGroup);
          console.log("scanTable1",scanTable1);
          let group = scanTable1[0].S;
          console.log("Group", group);
          console.log("Success, group has been obtained");
            
          // ----------Remove used code from the table
          let scanTable2 = scanTable.Items.map(x => x.id);
          console.log("SCAN TABLE 2: ", scanTable2)
          let elementId = scanTable2.map(x => x.S);
          console.log("elementId: ", elementId)
          console.log("event.request.userAttributes.zoneinfo: ", event.request.userAttributes.zoneinfo)
          var paramsUpdate = {
            ExpressionAttributeValues: {':p' : [{"L": event.request.userAttributes.zoneinfo }] },
            Key: {
              "id": {
                S: elementId[0]
              }
            }, 
            ReturnValues: 'ALL_NEW', 
            TableName: process.env.TableName, 
            UpdateExpression: `DELETE AssignedCodes :p`, 
          };
          
          try {
            let itemUpdated = await ddb.updateItem(paramsUpdate).promise();
            codeWasDeleted = true;
            console.log("Success, code used has been removed from table", itemUpdated);
          } catch (err) {
            console.log("Code used has not been removed from table ", err);
          }
          // // ----- Add a new code to the table if used code was deleted
          // if(codeWasDeleted){
          //   console.log("Adding new code to table...")
          //   //Random string function from https://stackoverflow.com/questions/10726909/random-alpha-numeric-string-in-javascript (user Nimphious)
            
          //   function randomString(length, chars) {
          //     //Prefix
          //     let prefix = '';
          //     if(group === 'Admin'){
          //       prefix = 'AD';
          //     }else if(group === 'ElevatorCompany'){
          //       prefix = 'EC';
          //     }else if(group === 'BuildingManager'){
          //       prefix = 'BM';
          //     }else{
          //       prefix = 'GU';
          //     }
          //     //Random string
          //     var mask = '';
          //     if (chars.indexOf('a') > -1) mask += 'abcdefghijklmnopqrstuvwxyz';
          //     if (chars.indexOf('A') > -1) mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
          //     if (chars.indexOf('#') > -1) mask += '0123456789';
          //     if (chars.indexOf('!') > -1) mask += '~`!@#$%^&*()_+-={}[]:";\'<>?,./|\\';
          //     var result = '';

          //     for (var i = length; i > 0; --i) result += mask[Math.round(Math.random() * (mask.length - 1))];

          //     //concat prefix to string
          //     result = prefix.concat(result);

          //     return result;
          //   }

          //   //Create a random to insert in dynamo db
          //   let codeToBeInserted = randomString(16, '#aA!')

            //Parameters 
            var paramsForNewCode = {
              ExpressionAttributeValues: {':p' : {"L": codeToBeInserted } },
              Key: {
                "id": {
                  S: elementId[0]
                }
              }, 
              ReturnValues: 'ALL_NEW', 
              TableName: process.env.TableName, 
              UpdateExpression: `ADD CurrentlyAvailableCodes :p`,
            };
            
            //Add new code to db
            try {
              const codesUpdated = await ddb.updateItem(paramsForNewCode).promise();
              console.log("Success, new code has been added to the table",codesUpdated);
            } catch (err) {
              console.log("Code has not been added to the table ", err);
            }
          }



          //----- assign user to a group
          const groupParams = {
            GroupName: group, 
            UserPoolId: event.userPoolId,
          };
          const addUserParams = {
            GroupName: group,
            UserPoolId: event.userPoolId,
            Username: event.userName,
          };
          /**
           * Check if the group exists; if it doesn't, create it.
           */
          try {
            await cognitoidentityserviceprovider.getGroup(groupParams).promise();
            console.log("Success, user has been assigned to a group",group);
          } catch (e) {
            await cognitoidentityserviceprovider.createGroup(groupParams).promise();
          }
          /**
           * Then, add the user to the group.
           */
          await cognitoidentityserviceprovider.adminAddUserToGroup(addUserParams).promise();
          // }   
        } catch (err) {
          console.log("Group has not been obtained", err);
          throw new Error(`The code ${event.request.userAttributes.zoneinfo} is not associated with any group`);
        }
      }
    } catch (err) {
      console.log("Print error", err);
      
    }

  return event;
};


CUSTOM RESOURCES

const aws = require('aws-sdk');
var ddb = new aws.DynamoDB();

const cognitoidentityserviceprovider = new aws.CognitoIdentityServiceProvider({
  apiVersion: '2016-04-18',
});

exports.handler = async (event, context) => {
  console.log("event.request.userAttributes:",event.request.userAttributes);
  console.log("event.request.userAttributes.email_verified:",event.request.userAttributes.email_verified);

    // --Read the group that the user belongs to 
    var paramsReadGroup = {
      UserPoolId: process.env.userPoolId, /* required */
      Username: event.request.userAttributes.sub, /* required */
    };
    try {
      let readGroupRes = await cognitoidentityserviceprovider.adminListGroupsForUser(paramsReadGroup).promise();
      let specificGroup  = readGroupRes.Groups.map(x => x.GroupName);
      console.log("Success, the group that the user belongs to has been obtained",specificGroup[0]);
      
      if (specificGroup[0]!=="Admin" || specificGroup[0]!=="ElevatorCompany" || specificGroup[0]!=="BuildingManager" || specificGroup[0]!=="Guest"){
        let codeWasDeleted = false;
          // --- read group according to code in dynamo table
        var paramsScan = {
        TableName: process.env.TableName,
        ScanFilter: {
          'AssignedCodes': {
            ComparisonOperator: 'CONTAINS',
            AttributeValueList: [
              { S: event.request.userAttributes.zoneinfo},
            ]
          },
        },
        };
        try {
          let scanTable = await ddb.scan(paramsScan).promise();
          console.log("scanTable:",scanTable);
          let scanTable1 = scanTable.Items.map(x => x.SignUpGroup);
          console.log("scanTable1",scanTable1);
          let group = scanTable1[0].S;
          console.log("Group", group);
          console.log("Success, group has been obtained");
            
          // ----------Remove used code from the table
          let scanTable2 = scanTable.Items.map(x => x.id);
          console.log("SCAN TABLE 2: ", scanTable2)
          let elementId = scanTable2.map(x => x.S);
          console.log("elementId: ", elementId)
          console.log("event.request.userAttributes.zoneinfo: ", event.request.userAttributes.zoneinfo)
          var paramsUpdate = {
            ExpressionAttributeValues: {':p' : [{"L": event.request.userAttributes.zoneinfo }] },
            Key: {
              "id": {
                S: elementId[0]
              }
            }, 
            ReturnValues: 'ALL_NEW', 
            TableName: process.env.TableName, 
            UpdateExpression: `DELETE AssignedCodes :p`, 
          };
          
          try {
            let itemUpdated = await ddb.updateItem(paramsUpdate).promise();
            codeWasDeleted = true;
            console.log("Success, code used has been removed from table", itemUpdated);
          } catch (err) {
            console.log("Code used has not been removed from table ", err);
          }
          // // ----- Add a new code to the table if used code was deleted
          // if(codeWasDeleted){
          //   console.log("Adding new code to table...")
          //   //Random string function from https://stackoverflow.com/questions/10726909/random-alpha-numeric-string-in-javascript (user Nimphious)
            
          //   function randomString(length, chars) {
          //     //Prefix
          //     let prefix = '';
          //     if(group === 'Admin'){
          //       prefix = 'AD';
          //     }else if(group === 'ElevatorCompany'){
          //       prefix = 'EC';
          //     }else if(group === 'BuildingManager'){
          //       prefix = 'BM';
          //     }else{
          //       prefix = 'GU';
          //     }
          //     //Random string
          //     var mask = '';
          //     if (chars.indexOf('a') > -1) mask += 'abcdefghijklmnopqrstuvwxyz';
          //     if (chars.indexOf('A') > -1) mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
          //     if (chars.indexOf('#') > -1) mask += '0123456789';
          //     if (chars.indexOf('!') > -1) mask += '~`!@#$%^&*()_+-={}[]:";\'<>?,./|\\';
          //     var result = '';

          //     for (var i = length; i > 0; --i) result += mask[Math.round(Math.random() * (mask.length - 1))];

          //     //concat prefix to string
          //     result = prefix.concat(result);

          //     return result;
          //   }

          //   //Create a random to insert in dynamo db
          //   let codeToBeInserted = randomString(16, '#aA!')

            //Parameters 
            var paramsForNewCode = {
              ExpressionAttributeValues: {':p' : {"L": codeToBeInserted } },
              Key: {
                "id": {
                  S: elementId[0]
                }
              }, 
              ReturnValues: 'ALL_NEW', 
              TableName: process.env.TableName, 
              UpdateExpression: `ADD CurrentlyAvailableCodes :p`,
            };
            
            //Add new code to db
            try {
              const codesUpdated = await ddb.updateItem(paramsForNewCode).promise();
              console.log("Success, new code has been added to the table",codesUpdated);
            } catch (err) {
              console.log("Code has not been added to the table ", err);
            }
          }



          //----- assign user to a group
          const groupParams = {
            GroupName: group, 
            UserPoolId: event.userPoolId,
          };
          const addUserParams = {
            GroupName: group,
            UserPoolId: event.userPoolId,
            Username: event.userName,
          };
          /**
           * Check if the group exists; if it doesn't, create it.
           */
          try {
            await cognitoidentityserviceprovider.getGroup(groupParams).promise();
            console.log("Success, user has been assigned to a group",group);
          } catch (e) {
            await cognitoidentityserviceprovider.createGroup(groupParams).promise();
          }
          /**
           * Then, add the user to the group.
           */
          await cognitoidentityserviceprovider.adminAddUserToGroup(addUserParams).promise();
          // }   
        } catch (err) {
          console.log("Group has not been obtained", err);
          throw new Error(`The code ${event.request.userAttributes.zoneinfo} is not associated with any group`);
        }
      }
    } catch (err) {
      console.log("Print error", err);
      
    }

  return event;
};




OCt 12



/**
 * @type {import('@types/aws-lambda').APIGatewayProxyHandler}
 */
const aws = require('aws-sdk');
const sns = new aws.SNS();
const sts = new aws.STS();
const cognitoidentityserviceprovider = new aws.CognitoIdentityServiceProvider();
const ddb = new aws.DynamoDB();

exports.handler = async (event) => {
    //Current logged in user's email
    console.log("event: ", event)

    function getAlerts() {
        console.log("List TEST")
        return {result: "get List test"};
      }
    
    /**
     * Resolver for getAlertsById - used to toggle a subscription on/off for a signal/elevator/user
     * @param {*} elevatorId 
     * @param {*} projectId 
     * @param {*} signal_type 
     * @returns 
     */
    const getAlertsById = async(elevatorId, projectId, signal_type, email, username) => {

        const userId = event.identity.username;
        const topicArn = `arn:aws:sns:${process.env.REGION}:${process.env.AwsAccountId}:${signal_type}`
        console.log("userId: ", userId)
        //-----------------get userType from cognito to decide if subscribe user to SNS or not---------------------------------------------
        const paramsGetUserType = {
            UserPoolId: process.env.userPoolId,
            Username: username,
        };
        try {
            const gettingUserType =  await cognitoidentityserviceprovider.adminListGroupsForUser(paramsGetUserType).promise();
            console.log("Yay, I got usertype with cognitoidentityserviceprovider:", gettingUserType);
            console.log("gettingUserType.Groups.GroupName:", gettingUserType.Groups[0].GroupName);
            if (gettingUserType.Groups[0].GroupName === "Admin" || gettingUserType.Groups[0].GroupName === "BuildingManager" || gettingUserType.Groups[0].GroupName === "ElevatorCompany"){
                //-----------------List subscriptions by topic:door_state_alert------check that user is Admin or ElevatorCompany or BuildingManager---------------------------------------
                const paramsListSubscriptions = {
                    TopicArn: topicArn, 
                };
                try {
                    const listOfSubs = await sns.listSubscriptionsByTopic(paramsListSubscriptions).promise();
                    console.log("Yay, I obtained the list subscriptions in SNS: ", listOfSubs);
                    //Find sub with the users email
                    const subFind = listOfSubs.Subscriptions.find(element => element.Endpoint === email)
                    console.log("subFind: ", subFind)


                    //-----------------Register User SNS--------check the user is not registered already-------------------------------------
                    if (subFind === undefined){
                        const paramsRegisterUserSNS = {
                            Protocol: 'email', 
                            TopicArn: `arn:aws:sns:${process.env.REGION}:${process.env.AwsAccountId}:door_state_alert`, 
                            Endpoint: email,
                            Attributes:{
                                'FilterPolicy':`{"elevatorAndProject":["${elevatorId}-${projectId}"]}`
                            },
                            ReturnSubscriptionArn: true
                        };

                        try {
                            
                            const dataRegisteredUserSNS = await sns.subscribe(paramsRegisterUserSNS).promise();
                            const newSubArn = dataRegisteredUserSNS.SubscriptionArn
                            console.log("Yay, I register a user in SNS!", dataRegisteredUserSNS);
                            //Update pending with sub data
                           
                            let allPending = [];
                            //Get all of the current pending
                            const paramsUser = {
                                Key: {'id': {S: userId}},//user ID
                                AttributesToGet: ['id', 'preferred_username', 'email','username','zoneinfo', 'subscriptions', 'pending_subscriptions'],
                                TableName: process.env.USERTABLE
                              };
                            let userData = await ddb.getItem(paramsUser).promise();
                            console.log("UserData: ", userData);
                            /**
                             * TO DO: DEAL WITH MULTIPLE PENDING SUBS
                             * If signal topic is pending add new project id to the filter policy otherwise just add a new pending
                             */
                            // const pendingSubs = JSON.parse(userData.Item.pending_subscriptions)
                            // console.log('')

                            //Object to be added to pending
                            const pendingObj = {
                                elevId: elevatorId,
                                projectId: projectId,
                                signalType: signal_type,
                                sub_arn: newSubArn
                            }
                            allPending.push({S:JSON.stringify(pendingObj)});
                            let date = new Date();
                            try{

                                const paramsUrl = {
                                  ExpressionAttributeNames: {
                                   "#UA": "updatedAt", 
                                   "#SB": "pending_subscriptions",
                                  }, 
                                  ExpressionAttributeValues: {
                                   ":ua": {S: date.toISOString()}, 
                                   ":sb": {L: allPending},
                                  }, 
                                  Key: {'id': {S: userId},},//USER ID
                                  ReturnValues: "ALL_NEW", 
                                  TableName: process.env.USERTABLE, 
                                  UpdateExpression: "SET #UA = :ua, #SB = :sb"
                                 };
                          
                                await ddb.updateItem(paramsUrl).promise();
                                console.log("Success, added subscriptions to user table");
                              } catch (err) {
                                console.log("Error adding subs:",err);
                              }
                        } catch (err) {
                            console.log("Error registering a user in SNS:",err);
                        }
                    //Else if user subscribed but filter doesn't have the elevator/project of the current subscription request add it to the filterPolicy
                    }else {
                                                /** 
                         * Check if it is already pending, if not create new sub
                         * 
                        */
                        const paramsUser = {
                            Key: {'id': {S: event.request.userAttributes.sub}},//user ID
                            AttributesToGet: ['id', 'email', 'subscriptions', 'pending_subscriptions'],
                            TableName: process.env.USERTABLE
                        };
                        const userData = await ddb.getItem(paramsUser).promise();
                
                        let pendingSubs = []
                        userData.Item.pending_subscriptions.L.forEach(ps => {
                            pendingSubs.push(JSON.parse(ps.S))
                        })
                        console.log("pendingSubs: ", pendingSubs)
                        /**-------------------------------------
                         * 
                         * 
                         */
                    
                        const subArn = subFind.SubscriptionArn
                        console.log("subArn: ", subArn)
                        const paramsForSubAttr = {
                            SubscriptionArn: subArn
                        };
                        if(subArn !== 'PendingConfirmation'){
                            const subAttrs = await sns.getSubscriptionAttributes(paramsForSubAttr).promise();
                            console.log("subAttrs: ", subAttrs)
                            const elevatorAndProject = JSON.parse(subAttrs.Attributes.FilterPolicy).elevatorAndProject;
                            console.log("elevatorAndProject: ", elevatorAndProject);
                            const topicArn = subAttrs.Attributes.TopicArn;
                            const findElevProject = elevatorAndProject.find(e => e === `${elevatorId}-${projectId}`)
                            console.log("findElevProject: ", findElevProject)
                            
                            if(findElevProject === undefined){
                                console.log(`Add ${elevatorId}-${projectId} to list of subs (${elevatorAndProject})`)
                                elevatorAndProject.push(`${elevatorId}-${projectId}`)
                                const filterPolicy = JSON.stringify({"elevatorAndProject":elevatorAndProject})
                                const snsAttrParams = {
                                    AttributeName: 'FilterPolicy', /* required */
                                    SubscriptionArn: subArn, /* required */
                                    AttributeValue: filterPolicy
                                };
                                console.log("snsAttrParams: ",snsAttrParams);
                                const updatedSubAttrs = await sns.setSubscriptionAttributes(snsAttrParams).promise();
                                console.log("Updated Sub Attrs: ", updatedSubAttrs)
                            }
                        }
                    }
                } catch (err) {
                    console.log("Error obtaining list of subscription in SNS:",err);
                }
            }
        } catch (err) {
            console.log("Error getting  test item from user table", err);
        }


        //Select which signal/topic is being toggled (sub/unsub)
        switch (signal_type) {
            case "door_state":
                console.log("door state topic")
                break;
            case "var_1":
                console.log("var_1")
                break;
            case "accel_x_axis_g":

                /**
                 * @type {import('@types/aws-lambda').APIGatewayProxyHandler}
                 */
                const aws = require('aws-sdk');
                const sns = new aws.SNS();
                const sts = new aws.STS();
                const cognitoidentityserviceprovider = new aws.CognitoIdentityServiceProvider();
                const ddb = new aws.DynamoDB();
                
                exports.handler = async (event) => {
                    //Current logged in user's email
                    console.log("event: ", event)
                
                    function getAlerts() {
                        console.log("List TEST")
                        return {result: "get List test"};
                      }
                    
                    /**
                     * Resolver for getAlertsById - used to toggle a subscription on/off for a signal/elevator/user
                     * @param {*} elevatorId 
                     * @param {*} projectId 
                     * @param {*} signal_type 
                     * @returns 
                     */
                    const getAlertsById = async(elevatorId, projectId, signal_type, email, username) => {
                
                        const userId = event.identity.username;
                        const topicArn = `arn:aws:sns:${process.env.REGION}:${process.env.AwsAccountId}:${signal_type}`
                        console.log("userId: ", userId)
                        //-----------------get userType from cognito to decide if subscribe user to SNS or not---------------------------------------------
                        const paramsGetUserType = {
                            UserPoolId: process.env.userPoolId,
                            Username: username,
                        };
                        try {
                            const gettingUserType =  await cognitoidentityserviceprovider.adminListGroupsForUser(paramsGetUserType).promise();
                            console.log("Yay, I got usertype with cognitoidentityserviceprovider:", gettingUserType);
                            console.log("gettingUserType.Groups.GroupName:", gettingUserType.Groups[0].GroupName);
                            if (gettingUserType.Groups[0].GroupName === "Admin" || gettingUserType.Groups[0].GroupName === "BuildingManager" || gettingUserType.Groups[0].GroupName === "ElevatorCompany"){
                                //-----------------List subscriptions by topic:door_state_alert------check that user is Admin or ElevatorCompany or BuildingManager---------------------------------------
                                const paramsListSubscriptions = {
                                    TopicArn: topicArn, 
                                };
                                try {
                                    const listOfSubs = await sns.listSubscriptionsByTopic(paramsListSubscriptions).promise();
                                    console.log("Yay, I obtained the list subscriptions in SNS: ", listOfSubs);
                                    //Find sub with the users email
                                    const subFind = listOfSubs.Subscriptions.find(element => element.Endpoint === email)
                                    console.log("subFind: ", subFind)
                
                
                                    //-----------------Register User SNS--------
                                    //If user is not already subscribed. Subscribe them and update dynamo user database
                                    if (subFind === undefined){
                                        console.log("IF")
                                        const paramsRegisterUserSNS = {
                                            Protocol: 'email', 
                                            TopicArn: `arn:aws:sns:${process.env.REGION}:${process.env.AwsAccountId}:door_state_alert`, 
                                            Endpoint: email,
                                            Attributes:{
                                                'FilterPolicy':`{"elevatorAndProject":["${elevatorId}-${projectId}"]}`
                                            },
                                            ReturnSubscriptionArn: true
                                        };
                
                                        try {
                                            
                                            const dataRegisteredUserSNS = await sns.subscribe(paramsRegisterUserSNS).promise();
                                            const newSubArn = dataRegisteredUserSNS.SubscriptionArn
                                            console.log("Yay, I register a user in SNS!", dataRegisteredUserSNS);
                                            //Update pending with sub data
                                           
                                            let allPending = [];
                                            //Get all of the current pending
                                            const paramsUser = {
                                                Key: {'id': {S: userId}},//user ID
                                                AttributesToGet: ['id', 'preferred_username', 'email','username','zoneinfo', 'subscriptions', 'pending_subscriptions'],
                                                TableName: process.env.USERTABLE
                                              };
                                            let userData = await ddb.getItem(paramsUser).promise();
                                            console.log("UserData: ", userData);
                                            /**
                                             * TO DO: DEAL WITH MULTIPLE PENDING SUBS
                                             * If signal topic is pending add new project id to the filter policy otherwise just add a new pending
                                             */
                                            // const pendingSubs = JSON.parse(userData.Item.pending_subscriptions)
                                            // console.log('')
                
                                            //Object to be added to pending
                                            const pendingObj = {
                                                elevId: elevatorId,
                                                projectId: projectId,
                                                signalType: signal_type,
                                                sub_arn: newSubArn
                                            }
                                            allPending.push({S:JSON.stringify(pendingObj)});
                                            let date = new Date();
                                            try{
                
                                                const paramsUrl = {
                                                  ExpressionAttributeNames: {
                                                   "#UA": "updatedAt", 
                                                   "#SB": "pending_subscriptions",
                                                  }, 
                                                  ExpressionAttributeValues: {
                                                   ":ua": {S: date.toISOString()}, 
                                                   ":sb": {L: allPending},
                                                  }, 
                                                  Key: {'id': {S: userId},},//USER ID
                                                  ReturnValues: "ALL_NEW", 
                                                  TableName: process.env.USERTABLE, 
                                                  UpdateExpression: "SET #UA = :ua, #SB = :sb"
                                                 };
                                          
                                                await ddb.updateItem(paramsUrl).promise();
                                                console.log("Success, added subscriptions to user table");
                                              } catch (err) {
                                                console.log("Error adding subs:",err);
                                              }
                                        } catch (err) {
                                            console.log("Error registering a user in SNS:",err);
                                        }
                                    //Else if user subscribed but filter doesn't have the elevator/project of the current subscription request add it to the filterPolicy
                                    }else {
                                        console.log("ELSE")
                                         /** 
                                         * Check if it is already pending
                                         * Add project/elevator to filter policy
                                        */
                                        
                                        const paramsUser = {
                                            Key: {'id': {S: event.arguments.userName}},//user ID
                                            AttributesToGet: ['id', 'email', 'subscriptions', 'pending_subscriptions'],
                                            TableName: process.env.USERTABLE
                                        };
                                        const userData = await ddb.getItem(paramsUser).promise();
                                        console.log("USERDATA: ", userData)
                                        let pendingSubs = []
                                        if(userData.Item.pending_subscriptions !== undefined){
                                            userData.Item.pending_subscriptions.L.forEach(ps => {
                                                pendingSubs.push(JSON.parse(ps.S))
                                            })
                                            console.log("pendingSubs: ", pendingSubs)
                                        }
                                        console.log("signal type: ", )
                                        //Look for a pending sub with same signal type but not the same project/elevator Id
                                        const pendingSubFound = pendingSubs.find(e =>  (e.signalType === signal_type && !(e.elevId === elevatorId && e.projectId === projectId)) )
                                        if(pendingSubFound !== undefined){
                                            const pendingSubArn = pendingSubFound.sub_arn
                                            console.log('pendingSubFound: ', pendingSubFound)
                                            console.log("ARN: ", pendingSubArn)
                                            //Use this to update the filter policy
                                            const paramsForPendingSubAttr = {
                                                SubscriptionArn: pendingSubArn
                                            };
                
                                            const pendingSubAttrs = await sns.getSubscriptionAttributes(paramsForPendingSubAttr).promise();
                                            console.log("pendingSubAttrs: ", pendingSubAttrs)
                                            const elevatorAndProjectForPending = JSON.parse(pendingSubAttrs.Attributes.FilterPolicy).elevatorAndProject;
                                            console.log("elevatorAndProject: ", elevatorAndProjectForPending);
                                            const findPendingElevProject = elevatorAndProjectForPending.find(e => e === `${elevatorId}-${projectId}`)
                                            console.log("findElevProject: ", findPendingElevProject)
                                            
                                            if(findPendingElevProject === undefined){
                                                console.log(`Add ${elevatorId}-${projectId} to list of subs (${elevatorAndProjectForPending})`)
                                                elevatorAndProjectForPending.push(`${elevatorId}-${projectId}`)
                                                const filterPolicy = JSON.stringify({"elevatorAndProject":elevatorAndProjectForPending})
                                                const snsAttrParamsPending = {
                                                    AttributeName: 'FilterPolicy', /* required */
                                                    SubscriptionArn: pendingSubArn, /* required */
                                                    AttributeValue: filterPolicy
                                                };
                                                console.log("snsAttrParams: ",snsAttrParamsPending);
                                                const updatedSubAttrsPending = await sns.setSubscriptionAttributes(snsAttrParamsPending).promise();
                                                console.log("updatedSubAttrsPending : ", updatedSubAttrsPending)
                                            }
                                        }
                                    
                                        /**-------------------------------------
                                         * 
                                         * 
                                         */
                                    
                                        const subArn = subFind.SubscriptionArn
                                        console.log("subArn: ", subArn)
                                        const paramsForSubAttr = {
                                            SubscriptionArn: subArn
                                        };
                                        //If it isn't pending and isn't a new subscription then update the existing filter policy 
                                        if(subArn !== 'PendingConfirmation'){
                                            const subAttrs = await sns.getSubscriptionAttributes(paramsForSubAttr).promise();
                                            console.log("subAttrs: ", subAttrs)
                                            const elevatorAndProject = JSON.parse(subAttrs.Attributes.FilterPolicy).elevatorAndProject;
                                            console.log("elevatorAndProject: ", elevatorAndProject);
                                            const findElevProject = elevatorAndProject.find(e => e === `${elevatorId}-${projectId}`)
                                            console.log("findElevProject: ", findElevProject)
                                            
                                            if(findElevProject === undefined){
                                                console.log(`Add ${elevatorId}-${projectId} to list of subs (${elevatorAndProject})`)
                                                elevatorAndProject.push(`${elevatorId}-${projectId}`)
                                                const filterPolicy = JSON.stringify({"elevatorAndProject":elevatorAndProject})
                                                const snsAttrParams = {
                                                    AttributeName: 'FilterPolicy', /* required */
                                                    SubscriptionArn: subArn, /* required */
                                                    AttributeValue: filterPolicy
                                                };
                                                console.log("snsAttrParams: ",snsAttrParams);
                                                const updatedSubAttrs = await sns.setSubscriptionAttributes(snsAttrParams).promise();
                                                console.log("Updated Sub Attrs: ", updatedSubAttrs)
                                            }
                                        }
                                    }
                                    
                                } catch (err) {
                                    console.log("Error obtaining list of subscription in SNS:",err);
                                }
                            }
                        } catch (err) {
                            console.log("Error getting  test item from user table", err);
                        }
                
                
                        //Select which signal/topic is being toggled (sub/unsub)
                        switch (signal_type) {
                            case "door_state":
                                console.log("door state topic")
                                break;
                            case "var_1":
                                console.log("var_1")
                                break;
                            case "accel_x_axis_g":
                                console.log("accel_x_axis_g")
                                break;
                            case "accel_y_axis_g":
                                console.log("accel_y_axis_g")
                                break;
                            case "accel_z_axis_g":
                                console.log("accel_z_axis_g")
                                break;
                            default:
                                break;
                        }
                
                        
                
                    /**
                     * 1 - Check which elevator is being queried (determines filter policy)
                     * 2 - Check which signal is being toggled (determines topic)
                     * 3 - Check if subscribing or unsubing (Then if filter needs editted or completely unsub)
                     * 4 - Sub/UnSub to this elevator
                     * 5 - Do this by getting the attributes for the sub and updating the list
                     * 
                     */
                
                
                
                
                    return {result: "get ID test"};
                    }
                    
                    const resolvers = {
                        Query:{
                            getListOfAlerts: () => {
                                return getAlerts();
                            },
                            getAlertById: (ctx) =>{
                                console.log("CTX: ", ctx)
                                return getAlertsById(ctx.arguments.elevator_id, ctx.arguments.project_id, ctx.arguments.signal_type, ctx.arguments.email, ctx.arguments.userName);
                            }
                        }
                      };
                    console.log("before last function");
                    console.log("Event: ", event)
                    const typeHandler = resolvers[event.typeName];
                    console.log("typeHandler: ", typeHandler)
                    if (typeHandler){
                        const resolver = typeHandler[event.fieldName];
                        if (resolver){
                            var result = await resolver(event);
                            console.log(result);
                            return result;
                        }
                    }
                    throw new Error("Resolver not found.");
                };
                
                console.log("accel_x_axis_g")
                break;
            case "accel_y_axis_g":
                console.log("accel_y_axis_g")
                break;
            case "accel_z_axis_g":
                console.log("accel_z_axis_g")
                break;
            default:
                break;
        }

        

    /**
     * 1 - Check which elevator is being queried (determines filter policy)
     * 2 - Check which signal is being toggled (determines topic)
     * 3 - Check if subscribing or unsubing (Then if filter needs editted or completely unsub)
     * 4 - Sub/UnSub to this elevator
     * 5 - Do this by getting the attributes for the sub and updating the list
     * 
     */




    return {result: "get ID test"};
    }
    
    const resolvers = {
        Query:{
            getListOfAlerts: () => {
                return getAlerts();
            },
            getAlertById: (ctx) =>{
                console.log("CTX: ", ctx)
                return getAlertsById(ctx.arguments.elevator_id, ctx.arguments.project_id, ctx.arguments.signal_type, ctx.arguments.email, ctx.arguments.userName);
            }
        }
      };
    console.log("before last function");
    console.log("Event: ", event)
    const typeHandler = resolvers[event.typeName];
    console.log("typeHandler: ", typeHandler)
    if (typeHandler){
        const resolver = typeHandler[event.fieldName];
        if (resolver){
            var result = await resolver(event);
            console.log(result);
            return result;
        }
    }
    throw new Error("Resolver not found.");
};


const subFind = listOfSubs.Subscriptions.find(element => element.Endpoint === email && (element.TopicArn.split(':')[5]) === signal_type)



LAMDA ROLE TEMPLATE updateSubscriptionStatus =
{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "{\"createdOn\":\"Mac\",\"createdBy\":\"Amplify\",\"createdWith\":\"10.0.0\",\"stackType\":\"function-Lambda\",\"metadata\":{}}",
  "Parameters": {
    "CloudWatchRule": {
      "Type": "String",
      "Default": "NONE",
      "Description": " Schedule Expression"
    },
    "deploymentBucketName": {
      "Type": "String"
    },
    "env": {
      "Type": "String"
    },
    "s3Key": {
      "Type": "String"
    },
    "awsAccountId": {
      "Type": "String"
    },
    "usertable": {
      "Type": "String"
    },
    "userPoolId": {
      "Type": "String"
    },
    "roleArn": {
      "Type": "String"
    }
  },
  "Conditions": {
    "ShouldNotCreateEnvResources": {
      "Fn::Equals": [
        {
          "Ref": "env"
        },
        "NONE"
      ]
    }
  },
  "Resources": {
    "LambdaFunction": {
      "Type": "AWS::Lambda::Function",
      "Metadata": {
        "aws:asset:path": "./src",
        "aws:asset:property": "Code"
      },
      "Properties": {
        "Code": {
          "S3Bucket": {
            "Ref": "deploymentBucketName"
          },
          "S3Key": {
            "Ref": "s3Key"
          }
        },
        "Handler": "index.handler",
        "FunctionName": {
          "Fn::If": [
            "ShouldNotCreateEnvResources",
            "updateSubscriptionStatus",
            {
              "Fn::Join": [
                "",
                [
                  "updateSubscriptionStatus",
                  "-",
                  {
                    "Ref": "env"
                  }
                ]
              ]
            }
          ]
        },
        "Environment": {
          "Variables": {
            "ENV": {
              "Ref": "env"
            },
            "REGION": {
              "Ref": "AWS::Region"
            },
            "AwsAccountId": {
              "Ref": "awsAccountId"
            },
            "USERTABLE": {
              "Ref": "usertable"
            },
            "userPoolId": {
              "Ref": "userPoolId"
            },
            "RoleArn": {
              "Ref": "roleArn"
            }
          }
        },
        "Role": {
          "Fn::GetAtt": [
            "LambdaExecutionRole",
            "Arn"
          ]
        },
        "Runtime": "nodejs14.x",
        "Layers": [],
        "Timeout": 25
      }
    },
    "LambdaExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "RoleName": {
          "Fn::If": [
            "ShouldNotCreateEnvResources",
            "neuvativLambdaRoleda475d3f",
            {
              "Fn::Join": [
                "",
                [
                  "neuvativLambdaRoleda475d3f",
                  "-",
                  {
                    "Ref": "env"
                  }
                ]
              ]
            }
          ]
        },
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": [
                  "lambda.amazonaws.com"
                ]
              },
              "Action": [
                "sts:AssumeRole"
              ]
            }
          ]
        }
      }
    },
    "lambdaexecutionpolicy": {
      "DependsOn": [
        "LambdaExecutionRole"
      ],
      "Type": "AWS::IAM::Policy",
      "Properties": {
        "PolicyName": "lambda-execution-policy",
        "Roles": [
          {
            "Ref": "LambdaExecutionRole"
          }
        ],
        "PolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Action": [
                "logs:CreateLogGroup",
                "logs:CreateLogStream",
                "logs:PutLogEvents"
              ],
              "Resource": {
                "Fn::Sub": [
                  "arn:aws:logs:${region}:${account}:log-group:/aws/lambda/${lambda}:log-stream:*",
                  {
                    "region": {
                      "Ref": "AWS::Region"
                    },
                    "account": {
                      "Ref": "AWS::AccountId"
                    },
                    "lambda": {
                      "Ref": "LambdaFunction"
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    }
  },
  "Outputs": {
    "Name": {
      "Value": {
        "Ref": "LambdaFunction"
      }
    },
    "Arn": {
      "Value": {
        "Fn::GetAtt": [
          "LambdaFunction",
          "Arn"
        ]
      }
    },
    "Region": {
      "Value": {
        "Ref": "AWS::Region"
      }
    },
    "LambdaExecutionRole": {
      "Value": {
        "Ref": "LambdaExecutionRole"
      }
    }
  }
}